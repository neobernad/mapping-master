options {
  LOOKAHEAD = 1;
  IGNORE_CASE = true;
  STATIC = false;
  USER_TOKEN_MANAGER=false;
  USER_CHAR_STREAM=false;
  OUTPUT_DIRECTORY = "../../../target/generated-sources/javacc";

  // JJTree options

  MULTI=true;
  NODE_DEFAULT_VOID = true;
  NODE_PACKAGE = "org.mm.parser.node";
  JJTREE_OUTPUT_DIRECTORY = "../../../target/generated-sources/jjtree";
}

PARSER_BEGIN(MappingMasterParser)

package org.mm.parser;

import org.mm.renderer.internal.ReferenceNotation;

import org.mm.directive.ReferenceDirectives;
import org.mm.directive.DefaultDirectives;

import java.util.*;

public class MappingMasterParser {

  private String prefix;
  private String namespace;
  private String language;

  private int referenceType;
  private int propertyType;

  private int valueDatatype;

  private int valueEncoding;
  private int iriEncoding;

  private int shiftDirection;

  private String labelValue;
  private String literalValue;

  private int orderIfCellEmpty;
  private int orderIfEntityAbsent;

  public MappingMasterParser(java.io.InputStream inputStream, int unused) {
    this(inputStream, new DefaultDirectives(), unused);
  }

  public MappingMasterParser(java.io.InputStream inputStream, ReferenceDirectives systemDirectives, int unused) {
    this(inputStream);
    prefix = systemDirectives.getPrefix();
    namespace = systemDirectives.getNamespace();
    language = systemDirectives.getLanguage();
    referenceType = systemDirectives.getReferenceType();
    propertyType = systemDirectives.getPropertyType();
    valueDatatype = systemDirectives.getValueDatatype();
    valueEncoding = systemDirectives.getValueEncoding();
    iriEncoding = systemDirectives.getIriEncoding();
    shiftDirection = systemDirectives.getShiftDirection();
    labelValue = systemDirectives.getLabelValue();
    literalValue = systemDirectives.getLiteralValue();
    orderIfCellEmpty = systemDirectives.getOrderIfCellEmpty();
    orderIfEntityAbsent = systemDirectives.getOrderIfEntityAbsent();
  }

  public SimpleNode getTransformationRuleNode() throws ParseException {
    return transformation_rule();
  }
}

PARSER_END(MappingMasterParser)

/* White space */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* Comments */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* Manchester Syntax keywords */

TOKEN: { <CLASS: "Class:" | "class:"> }
TOKEN: { <INDIVIDUAL: "Individual:" | "individual:"> }
TOKEN: { <EQUIVALENT_TO: "EquivalentTo:" | "equivalentTo:"> }
TOKEN: { <SUBCLASS_OF: "SubClassOf:" | "subClassOf:"> }
TOKEN: { <FACTS: "Facts:" | "facts:"> }
TOKEN: { <TYPES: "Types:" | "types:"> }
TOKEN: { <ANNOTATIONS: "Annotations:" | "annotations:"> }
TOKEN: { <SAME_AS: "SameAs:" | "sameAs:"> }
TOKEN: { <DIFFERENT_FROM: "DifferentFrom:" | "differentFrom:"> }
TOKEN: { <SOME: "some" | "SOME">}
TOKEN: { <ONLY: "only" | "ONLY">}
TOKEN: { <VALUE: "value" | "VALUE">}
TOKEN: { <MIN: "min" | "MIN">}
TOKEN: { <MAX: "max" | "MAX">}
TOKEN: { <EXACTLY: "exactly" | "EXACTLY">}
TOKEN: { <AND: "and" | "AND">}
TOKEN: { <OR: "or" | "OR">}
TOKEN: { <NOT: "not" | "NOT">}

/* Boolean keywords */

TOKEN: {<TRUE: "true" | "TRUE">}
TOKEN: {<FALSE: "false" | "FALSE">}

/* Datatypes */

TOKEN: { <XSD_STRING: "xsd:string" > }
TOKEN: { <XSD_DECIMAL: "xsd:decimal" > }
TOKEN: { <XSD_BYTE: "xsd:byte" > }
TOKEN: { <XSD_SHORT: "xsd:short" > }
TOKEN: { <XSD_INTEGER: "xsd:integer" > }
TOKEN: { <XSD_LONG: "xsd:long" > }
TOKEN: { <XSD_FLOAT: "xsd:float"  > }
TOKEN: { <XSD_DOUBLE: "xsd:double" > }
TOKEN: { <XSD_BOOLEAN: "xsd:boolean" > }
TOKEN: { <XSD_DATETIME: "xsd:dateTime"> }
TOKEN: { <XSD_TIME: "xsd:time"> }
TOKEN: { <XSD_DURATION: "xsd:duration" > }
TOKEN: { <XSD_DATE: "xsd:date" > }
TOKEN: { <RDF_XMLLITERAL: "rdf:XMLLiteral" > }
TOKEN: { <RDF_PLAINLITERAL: "rdf:PlainLiteral" > }

/*
TOKEN: { <XSD_NOTATION: "xsd:NOTATION" > }
TOKEN: { <XSD_UNSIGNEDLONG: "xsd:unsignedLong" > }
TOKEN: { <XSD_ANYSIMPLETYPE: "xsd:anySimpleType" > }
TOKEN: { <XSD_HEXBINARY: "xsd:hexBinary" > }
TOKEN: { <XSD_NONPOSITIVEINTEGER: "xsd:nonPositiveInteger" > }
TOKEN: { <XSD_NONNEGATIVEINTEGER: "xsd:nonNegativeInteger" > }
TOKEN: { <XSD_NORMALIZEDSTRING: "xsd:normalizedString" > }
TOKEN: { <XSD_POSITIVEINTEGER: "xsd:positiveInteger" > }
TOKEN: { <XSD_ENTITY: "xsd:ENTITY" > }
TOKEN: { <XSD_LANGUAGE: "xsd:language" > }
TOKEN: { <XSD_GMONTHDAY: "xsd:gMonthDay" > }
TOKEN: { <XSD_ANYURI: "xsd:anyURI" > }
TOKEN: { <XSD_NAME: "xsd:Name" > }
TOKEN: { <XSD_GYEARMONTH: "xsd:gYearMonth" > }
TOKEN: { <XSD_QNAME: "xsd:QName" > }
TOKEN: { <XSD_NEGATIVEINTEGER: "xsd:negativeInteger" > }
TOKEN: { <XSD_BASE64BINARY: "xsd:base64Binary" > }
TOKEN: { <XSD_ID: "xsd:ID" > }
TOKEN: { <XSD_TOKEN: "xsd:token" > }
TOKEN: { <XSD_UNSIGNEDINT: "xsd:unsignedInt" > }
TOKEN: { <XSD_IDREF: "xsd:IDREF" > }
TOKEN: { <XSD_UNSIGNEDBYTE: "xsd:unsignedByte" > }
TOKEN: { <XSD_GDAY: "xsd:gDay" > }
TOKEN: { <XSD_GYEAR: "xsd:gYear" > }
TOKEN: { <XSD_NCNAME: "xsd:NCName" > }
TOKEN: { <XSD_BYTE: "xsd:byte" > }
TOKEN: { <XSD_GMONTH: "xsd:gMonth" > }
TOKEN: { <XSD_UNSIGNEDSHORT: "xsd:unsignedShort" > }
TOKEN: { <XSD_NMTOKEN: "xsd:NMTOKEN" > }
*/

/* MappingMaster tokens */

TOKEN: { <RDF_ID: "rdf:ID"> }
TOKEN: { <RDFS_LABEL: "rdfs:label"> }
TOKEN: { <XML_LANG: "xml:lang" > }

TOKEN: { <MM_DEFAULT_VALUE_ENCODING: "mm:DefaultValueEncoding"> }
TOKEN: { <MM_DEFAULT_IRI_ENCODING: "mm:DefaultIRIEncoding"> }
TOKEN: { <MM_DEFAULT_SHIFT_DIRECTION: "mm:DefaultShiftDirection"> }
TOKEN: { <MM_DEFAULT_REFERENCE_TYPE: "mm:DefaultReferenceType"> }
TOKEN: { <MM_DEFAULT_PROPERTY_TYPE: "mm:DefaultPropertyType"> }
TOKEN: { <MM_DEFAULT_VALUE_DATATYPE: "mm:DefaultValueDatatype"> }

TOKEN: { <MM_DEFAULT_ORDER_IF_CELL_EMPTY: "mm:DefaultOrderIfCellEmpty"> }
TOKEN: { <MM_DEFAULT_ORDER_IF_ENTITY_ABSENT: "mm:DefaultOrderIfEntityAbsent"> }

TOKEN: { <MM_PREFIX: "mm:Prefix"> }
TOKEN: { <MM_NAMESPACE: "mm:Namespace"> }
TOKEN: { <MM_VALUE_ENCODING: "mm:ValueEncoding"> }
TOKEN: { <MM_IRI_ENCODING: "mm:IRIEncoding"> }

TOKEN: { <MM_UNTYPED: "mm:Untyped"> }
TOKEN: { <MM_NULL: "mm:Null" > }

TOKEN: { <CELL_WILDCARD: "*"> }

TOKEN: { <OWL_CLASS: "Class"> }
TOKEN: { <OWL_NAMED_INDIVIDUAL: "Individual"> }
TOKEN: { <OWL_OBJECT_PROPERTY: "ObjectProperty"> }
TOKEN: { <OWL_DATA_PROPERTY: "DataProperty"> }
TOKEN: { <OWL_ANNOTATION_PROPERTY: "AnnotationProperty"> }
TOKEN: { <OWL_LITERAL: "Literal"> }
TOKEN: { <OWL_DATATYPE: "Datatype"> }
TOKEN: { <OWL_IRI: "IRI"> }
TOKEN: { <MM_ENTITY_IRI: "mm:entityIRI"> }

TOKEN: { <MM_TO_UPPER_CASE: "mm:toUpperCase"> }
TOKEN: { <MM_TO_LOWER_CASE: "mm:toLowerCase"> }
TOKEN: { <MM_TRIM: "mm:trim"> }
TOKEN: { <MM_PRINTF: "mm:printf"> }
TOKEN: { <MM_DECIMAL_FORMAT: "mm:decimalFormat"> }
TOKEN: { <MM_CAPTURING: "mm:capturing"> }
TOKEN: { <MM_REVERSE: "mm:reverse"> }
TOKEN: { <MM_REPLACE: "mm:replace"> }
TOKEN: { <MM_REPLACE_ALL: "mm:replaceAll"> }
TOKEN: { <MM_REPLACE_FIRST: "mm:replaceFirst"> }
TOKEN: { <MM_APPEND: "mm:append"> }
TOKEN: { <MM_PREPEND: "mm:prepend"> }

TOKEN: { <MM_NO_ENCODE: "mm:noEncode"> }
TOKEN: { <MM_CAMELCASE_ENCODE: "mm:camelCaseEncode"> }
TOKEN: { <MM_SNAKECASE_ENCODE: "mm:snakeCaseEncode"> }
TOKEN: { <MM_UUID_ENCODE: "mm:uuidEncode"> }
TOKEN: { <MM_HASH_ENCODE: "mm:hashEncode"> }

TOKEN: { <MM_DEFAULT_LITERAL: "mm:DefaultLiteral"> }
TOKEN: { <MM_DEFAULT_LABEL: "mm:DefaultLabel"> }

TOKEN: { <MM_DEFAULT_PREFIX: "mm:DefaultPrefix"> }
TOKEN: { <MM_DEFAULT_NAMESPACE: "mm:DefaultNamespace"> }
TOKEN: { <MM_DEFAULT_LANGUAGE: "mm:DefaultLanguage"> }

TOKEN: { <MM_NO_SHIFT: "mm:NoShift"> }
TOKEN: { <MM_SHIFT_UP: "mm:shiftUp"> }
TOKEN: { <MM_SHIFT_DOWN: "mm:shiftDown"> }
TOKEN: { <MM_SHIFT_LEFT: "mm:shiftLeft"> }
TOKEN: { <MM_SHIFT_RIGHT: "mm:shiftRight"> }

TOKEN: { <MM_CREATE_IF_CELL_EMPTY: "mm:createIfCellEmpty"> }
TOKEN: { <MM_IGNORE_IF_CELL_EMPTY: "mm:ignoreIfCellEmpty"> }
TOKEN: { <MM_WARNING_IF_CELL_EMPTY: "mm:warningIfCellEmpty"> }
TOKEN: { <MM_ERROR_IF_CELL_EMPTY: "mm:errorIfCellEmpty"> }

TOKEN: { <MM_CREATE_IF_ENTITY_ABSENT: "mm:createIfEntityAbsent"> }
TOKEN: { <MM_IGNORE_IF_ENTITY_ABSENT: "mm:ignoreIfEntityAbsent"> }
TOKEN: { <MM_WARNING_IF_ENTITY_ABSENT: "mm:warningIfEntityAbsent"> }
TOKEN: { <MM_ERROR_IF_ENTITY_ABSENT: "mm:errorIfEntityAbsent"> }

TOKEN: { <CREATE: "CREATE"> }
TOKEN: { <IGNORE: "IGNORE"> }
TOKEN: { <WARNING: "WARNING"> }
TOKEN: { <ERROR: "ERROR"> }

TOKEN:
{
<IRI_REF: "<" (~[ ">","<", "\"", "{", "}", "^", "\\", "|", "`", "\u0000"-"\u0020"])* ">" >
| <STRING_LITERAL: "\"" (~["\""])* ("\"\"" (~["\""])*)* ("\\\"")* "\"" >
| <INTEGER_LITERAL: (["-"])? (<DIGIT>)+ > 
| <LONG_LITERAL: (["-"])? (<DIGIT>)+> 
| <FLOAT_LITERAL: (["-"])? (<DIGIT>)+ "." (<DIGIT>)+ (<EXPONENT>)?
                  | (["-"])? "." (<DIGIT>)+ (<EXPONENT>)?
                  | (["-"])? (<DIGIT>)+ <EXPONENT>
                  | (["-"])? (<DIGIT>)+ (<EXPONENT>)? > 
| <QUOTED_NAME: "'" (~["'"])* ("''" (~["'"])*)* "'" >
| <#LETTER: [ "a"-"z", "A"-"Z" ]>
| <#DIGIT: ["0"-"9"] >
| <#EXPONENT: ["e", "E"] (["+", "-"])? (<DIGIT>)+ >
| <CELL_REFERENCE: ((<LETTER>)+ | "*") ((<DIGIT>)+ | "*")>
| <NAME: <LETTER> ( <LETTER> | <DIGIT> | "_" | "-" | "." )* >
}

//------------------------------------------------------------------------------------------
// MM Transformation Rule
//------------------------------------------------------------------------------------------

SimpleNode transformation_rule() #TransformationRule : {}
{
  (  rule_directive()
    | rule_expression()
  ) <EOF>
  {
    return jjtThis;
  }
}

//------------------------------------------------------------------------------------------
// MM Rule Directives
//------------------------------------------------------------------------------------------

void rule_directive() : {}
{
  ( mm_default_prefix_directive()
    | mm_default_namespace_directive()
    | mm_default_language_directive()
    | mm_default_reference_type_directive()
    | mm_default_property_type_directive()
    | mm_default_value_datatype_directive()
    | mm_default_value_encoding_directive()
    | mm_default_iri_encoding_directive()
    | mm_default_label_value_directive()
    | mm_default_literal_value_directive()
    | mm_default_order_if_cell_empty_directive()
    | mm_default_order_if_entity_absent_directive()
  )
}

void mm_default_prefix_directive() :
{
  String defaultPrefix;
}
{
  <MM_DEFAULT_PREFIX> "=" defaultPrefix = string_value()
  {
    prefix = defaultPrefix;
  }
}

void mm_default_namespace_directive() :
{
  String defaultNamespace;
}
{
  <MM_DEFAULT_NAMESPACE> "=" defaultNamespace = string_value()
  {
    namespace = defaultNamespace;
  }
}

void mm_default_language_directive() :
{
  String defaultLanguage;
}
{
  <MM_DEFAULT_LANGUAGE> "=" defaultLanguage = string_value()
  {
    language = defaultLanguage;
  }
}

void mm_default_reference_type_directive() :
{
  int defaultReferenceType;
}
{
  <MM_DEFAULT_REFERENCE_TYPE> "=" defaultReferenceType = reference_type()
  {
    referenceType = defaultReferenceType;
  }
}

void mm_default_property_type_directive() :
{
  int defaultPropertyType;
}
{
  <MM_DEFAULT_PROPERTY_TYPE> "=" defaultPropertyType = property_type()
  {
    propertyType = defaultPropertyType;
  }
}

void mm_default_value_datatype_directive() :
{
  int defaultValueDatatype;
}
{
  <MM_DEFAULT_VALUE_DATATYPE> "=" defaultValueDatatype = datatype()
  {
    valueDatatype = defaultValueDatatype;
  }
}

void mm_default_value_encoding_directive() :
{
  int defaultValueEncoding;
}
{
  <MM_DEFAULT_VALUE_ENCODING> "=" defaultValueEncoding = value_encoding()
  {
    valueEncoding = defaultValueEncoding;
  }
}

void mm_default_iri_encoding_directive() :
{
  int defaultIriEncoding;
}
{
  <MM_DEFAULT_IRI_ENCODING> "=" defaultIriEncoding = iri_encoding()
  {
    iriEncoding = defaultIriEncoding;
  }
}

void mm_default_shift_direction_directive() :
{
  int defaultShiftDirection;
}
{
  <MM_DEFAULT_SHIFT_DIRECTION> "=" defaultShiftDirection = shift_direction()
  {
    shiftDirection = defaultShiftDirection;
  }
}

void mm_default_label_value_directive() :
{
  String defaultLabelValue;
}
{
  <MM_DEFAULT_LABEL> "=" defaultLabelValue = string_value()
  {
    labelValue = defaultLabelValue;
  }
}

void mm_default_literal_value_directive() :
{
  String defaultLiteralValue;
}
{
  <MM_DEFAULT_LITERAL> "=" defaultLiteralValue = string_value()
  {
    literalValue = defaultLiteralValue;
  }
}

void mm_default_order_if_cell_empty_directive() :
{
  int defaultOrderIfCellEmpty;
}
{
  <MM_DEFAULT_ORDER_IF_CELL_EMPTY> "=" defaultOrderIfCellEmpty = order_type()
  {
    orderIfCellEmpty = defaultOrderIfCellEmpty;
  }
}

void mm_default_order_if_entity_absent_directive() :
{
  int defaultOrderIfEntityAbsent;
}
{
  <MM_DEFAULT_ORDER_IF_ENTITY_ABSENT> "=" defaultOrderIfEntityAbsent = order_type()
  {
    orderIfEntityAbsent = defaultOrderIfEntityAbsent;
  }
}

//------------------------------------------------------------------------------------------
// MM Rule Expression
//------------------------------------------------------------------------------------------

void rule_expression() #RuleExpression : {}
{
  ( class_frame()
   | individual_frame()
  )
  // TODO datatype, object property, data property, and annotation property declarations
  // TODO negative property assertions, disjoint classes, disjoint properties, equivalent properties
  // See: http://www.w3.org/TR/owl2-manchester-syntax/
}

//------------------------------------------------------------------------------------------
// MM Class Frame
//------------------------------------------------------------------------------------------

void class_frame() #ClassFrame : {}
{
  class_declaration()
  ( subclass_of()
    | equivalent_classes()
    | annotation_assertion()
  )*
  // TODO Other clauses: DisjointWith, DisjoinUnionOf, HasKey
  // See: http://www.w3.org/TR/owl2-manchester-syntax/
}

void class_declaration() #ClassDeclaration : {}
{
  <CLASS> atomic_class()
}

void subclass_of() #SubclassOf : {}
{
  <SUBCLASS_OF> class_expression() ( "," class_expression() )*
}

void equivalent_classes() #EquivalentClasses : {}
{
  <EQUIVALENT_TO> class_expression() ( "," class_expression() )*
}

void annotation_assertion() #AnnotationAssertion : {}
{
  <ANNOTATIONS> annotation() ( "," annotation() )*
}

void annotation() #Annotation : {}
{
  annotation_property() annotation_value()
}

void annotation_value() #AnnotationValue : {}
{
  ( reference(valueDatatype)
    | iri()
    | literal()
  )
}

//------------------------------------------------------------------------------------------
// MM Individual Frame
//------------------------------------------------------------------------------------------

void individual_frame() #IndividualFrame : {}
{
  individual_declaration()
  ( class_assertion()
    | property_assertion()
    | annotation_assertion()
    | same_as()
    | different_from()
  )*
}

void individual_declaration() #IndividualDeclaration : {}
{
  <INDIVIDUAL> named_individual()
}

void class_assertion() #ClassAssertion : {}
{
  <TYPES> class_expression() ( "," class_expression() )*
}

void property_assertion() #PropertyAssertion : {}
{
  <FACTS> fact() ( "," fact() )*
}

void fact() #Fact : {}
{
  property() property_value()
}

void property_value() #PropertyValue : {}
{
  ( reference(XSD_STRING)
    | qname()
    | literal()
  )
}

void same_as() #SameAs : {}
{
  <SAME_AS> named_individual() ( "," named_individual() )*
}

void different_from() #DifferentFrom : {}
{
  <DIFFERENT_FROM>  named_individual() ( "," named_individual() )*
}

//------------------------------------------------------------------------------------------
// OWL Class Expression
//------------------------------------------------------------------------------------------

void class_expression() #ClassExpressionCategory : {}
{
  ( LOOKAHEAD(3) atomic_class()
    | "(" boolean_class_expression() ")"
    | object_one_of()
    | restriction()
  )
}

void atomic_class() #Class : {}
{
  value(OWL_CLASS)
}

void boolean_class_expression() : {}
{
  ( object_union_of()
    | object_complement_of()
  )
}

void object_union_of() #ObjectUnion : {}
{
  object_intersection_of() ( <OR> object_intersection_of() )*
}

void object_intersection_of() #ObjectIntersection : {}
{
  class_expression() ( <AND> class_expression() )*
}

void object_complement_of() #ObjectComplement : {}
{
  <NOT> class_expression()
}

void object_one_of() #ObjectOneOf : {}
{
  "{" named_individual() ( "," named_individual() )* "}"
}

//------------------------------------------------------------------------------------------
// OWL Restriction
//------------------------------------------------------------------------------------------

void restriction() : {}
{
  ( LOOKAHEAD(2) exact_cardinality()
    | LOOKAHEAD(2) max_cardinality()
    | LOOKAHEAD(2) min_cardinality()
    | LOOKAHEAD(2) has_value()
    | LOOKAHEAD(2) all_values_from()
    | some_values_from()
  )
}

void exact_cardinality() : {}
{
  ( LOOKAHEAD(4) data_exact_cardinality()
    | object_exact_cardinality()
  )
}

void data_exact_cardinality() #DataExactCardinality :
{
  int cardinality;
  int datatype;
}
{
  data_property() <EXACTLY> cardinality = cardinality_value() datatype = datatype()
  {
    jjtThis.cardinality = cardinality;
    jjtThis.datatype = datatype;
  }
}

void object_exact_cardinality() #ObjectExactCardinality :
{
  int cardinality;
  boolean hasExplicitClassExpression = false;
}
{
  object_property() <EXACTLY> cardinality = cardinality_value()
      ( "(" class_expression() ")" { hasExplicitClassExpression = true; } )?
  {
    jjtThis.cardinality = cardinality;
    jjtThis.hasExplicitClassExpression = hasExplicitClassExpression;
  }
}

void max_cardinality() : {}
{
  ( LOOKAHEAD(4) data_max_cardinality()
    | object_max_cardinality()
  )
}

void data_max_cardinality() #DataMaxCardinality :
{
  int cardinality;
  int datatype;
}
{
  data_property() <MAX> cardinality = cardinality_value() datatype = datatype()
  {
    jjtThis.cardinality = cardinality;
    jjtThis.datatype = datatype;
  }
}

void object_max_cardinality() #ObjectMaxCardinality :
{
  int cardinality;
  boolean hasExplicitClassExpression = false;
}
{
  object_property() <MAX> cardinality = cardinality_value()
      ( "(" class_expression() ")" { hasExplicitClassExpression = true; } )?
      
  {
    jjtThis.cardinality = cardinality;
    jjtThis.hasExplicitClassExpression = hasExplicitClassExpression;
  }
}

void min_cardinality() : {}
{
  ( LOOKAHEAD(4) data_min_cardinality()
    | object_min_cardinality()
  )
}

void data_min_cardinality() #DataMinCardinality :
{
  int cardinality;
  int datatype;
}
{
  data_property() <MIN> cardinality = cardinality_value() datatype = datatype()
  {
    jjtThis.cardinality = cardinality;
    jjtThis.datatype = datatype;
  }
}

void object_min_cardinality() #ObjectMinCardinality :
{
  int cardinality;
  boolean hasExplicitClassExpression = false;
}
{
  object_property() <MIN> cardinality = cardinality_value()
      ( "(" class_expression() ")" { hasExplicitClassExpression = true; } )?
      
  {
    jjtThis.cardinality = cardinality;
    jjtThis.hasExplicitClassExpression = hasExplicitClassExpression;
  }
}

int cardinality_value() :
{
  int cardinality;
}
{
  cardinality  = integer_value()
  {
    return cardinality;
  }
}

void has_value() : {}
{
  ( LOOKAHEAD(3) data_has_value()
    | object_has_value()
  )
}

void data_has_value() #DataHasValue : {}
{
  data_property() <VALUE> literal_value()
}

void object_has_value() #ObjectHasValue : {}
{
  object_property() <VALUE> object_value()
}

void all_values_from() : {}
{
  ( LOOKAHEAD(3) data_all_values_from()
    | object_all_values_from()
  )
}

void data_all_values_from() #DataAllValuesFrom :
{
  int datatype;
}
{
  property() <ONLY> datatype = datatype()
  {
    jjtThis.datatype = datatype;
  }
}

void object_all_values_from() #ObjectAllValuesFrom : {}
{
  property() <ONLY> class_expression()
}

void some_values_from() : {}
{
  ( LOOKAHEAD(3) data_some_values_from()
    | object_some_values_from()
  )
}

void data_some_values_from() #DataSomeValuesFrom :
{
  int datatype;
}
{
  property() <SOME> datatype = datatype()
  {
    jjtThis.datatype = datatype;
  }
}

void object_some_values_from() #ObjectSomeValuesFrom : {}
{
  property() <SOME> class_expression()
}

//------------------------------------------------------------------------------------------
// OWL Property
//------------------------------------------------------------------------------------------

void property() #Property : {}
{
  value(propertyType)
}

void data_property() #DataProperty : {}
{
  value(OWL_DATA_PROPERTY)
}

void object_property() #ObjectProperty : {}
{
  value(OWL_OBJECT_PROPERTY)
}

void annotation_property() #AnnotationProperty: {}
{
  value(OWL_ANNOTATION_PROPERTY)
}

//------------------------------------------------------------------------------------------
// OWL Named Individual
//------------------------------------------------------------------------------------------

void named_individual() #NamedIndividual : {}
{
  value(OWL_NAMED_INDIVIDUAL)
}

//------------------------------------------------------------------------------------------
// Value Category
//------------------------------------------------------------------------------------------

void value(int referenceType) #ValueCategory : {}
{
  ( reference(referenceType)
    | qname()
    | iri()
    | literal()
  )
}

void literal_value() #LiteralValue : {}
{
  ( reference(valueDatatype)
    | literal()
  )
}

void object_value() #ObjectValue() : {}
{
  ( reference(OWL_NAMED_INDIVIDUAL)
    | qname()
  )
}

void reference(int type) #Reference :
{
  referenceType = type;
  ReferenceDirectives referenceDirectives;
  boolean hasBuiltInFunction = false;
}
{
  reference_notation()
    ( LOOKAHEAD(2)
       "(" ( reference_directive() )* ( builtin_function() { jjtThis.hasBuiltInFunction = true; })? ")"
    )?
  {
    jjtThis.referenceDirectives = new ReferenceDirectives(
        prefix, namespace, language, labelValue, literalValue,
        referenceType, propertyType, valueDatatype,
        valueEncoding, iriEncoding, shiftDirection,
        orderIfCellEmpty, orderIfEntityAbsent);
  }
}

void name() #Name :
{
  Token t;
}
{
  t = <NAME>
  {
    jjtThis.name = t.image;
  }
}

void qname() #QName :
{
  String qname;
}
{
  <RDFS_LABEL> { jjtThis.name = "rdfs:label"; } // TODO: Remove this after having a clear decision on "rdfs:label" directive
  | ( LOOKAHEAD(2) qname = prefixed_name()
      | LOOKAHEAD(2) qname = unprefixed_name()
    )
    {
      jjtThis.name = qname;
    }
}

String prefixed_name() :
{
  Token t1;
  Token t2;
}
{
  t1 = <NAME> ":" t2 = <NAME>
  {
    return t1.image + ":" + t2.image;
  }
}

String unprefixed_name() :
{
  Token t;
}
{
  t = <NAME>
  {
    return t.image;
  }
}

void iri() #Iri :
{
  Token t;
}
{
  t = <IRI_REF>
  {
    jjtThis.iri = t.image;
  }
}

void literal() #Literal : {}
{
  ( integer_literal()
   | float_literal()
   | string_literal()
   | boolean_literal()
  )
} 

void integer_literal() #IntegerLiteral :
{
  int value;
}
{
  value = integer_value()
  {
    jjtThis.lexicalValue = value;
  }
}

void float_literal() #FloatLiteral :
{
  float value;
}
{
  value = float_value()
  {
    jjtThis.lexicalValue = value;
  }
}

void string_literal() #StringLiteral :
{
  String value;
}
{
  value = string_value()
  {
    jjtThis.lexicalValue = value;
  }
}

void boolean_literal() #BooleanLiteral :
{
  boolean value;
}
{
  value = boolean_value()
  {
    jjtThis.lexicalValue = value;
  }
}

//------------------------------------------------------------------------------------------
// Cell Reference
//------------------------------------------------------------------------------------------

void reference_notation() #ReferenceNotation :
{
  String cellReference;
}
{
  ( "@" cellReference = cell_reference() )
  {
    jjtThis.referenceNotation = new ReferenceNotation(cellReference);
  }
}

String quoted_name() :
{
  Token t;
}
{
  t = <QUOTED_NAME>
  {
    String s = t.image;
    return s.substring(1, s.length() - 1);
  }
}

String cell_reference() :
{
  Token t;
}
{
  t = <CELL_REFERENCE>
  {
    return t.image;
  }
}

//------------------------------------------------------------------------------------------
// Reference Directives
//------------------------------------------------------------------------------------------

void reference_directive() :
{
  int value;
}
{
  ( prefix_directive()
   | namespace_directive()
   | language_directive()
   | value = reference_type() { referenceType = value; }
   | value = value_encoding() { valueEncoding = value; }
   | value = iri_encoding() { iriEncoding = value; }
   | value = shift_direction() { shiftDirection = value; }
   | value = order_if_cell_empty() { orderIfCellEmpty = value; }
   | value = order_if_entity_absent() { orderIfEntityAbsent = value; }
  )
}

void prefix_directive() :
{
  String prefixValue;
}
{
  <MM_PREFIX> "=" prefixValue = string_value()
  {
    prefix = prefixValue;
  }
}

void namespace_directive() :
{
  String namespaceValue;
}
{
  <MM_NAMESPACE> "=" namespaceValue = string_value()
  {
    namespace = namespaceValue;
  }
}

void language_directive() :
{
  String languageValue;
}
{
  <XML_LANG> ( "=" ( <MM_NULL> { languageValue = ""; }
                     | "*" { languageValue = "*"; }
                     | languageValue = string_value()
                   )
               | ( "!" "=" <MM_NULL> { languageValue = "+"; } )
             )
  {
    language = languageValue;
    referenceType = RDF_PLAINLITERAL;
    valueDatatype = RDF_PLAINLITERAL;
  }
}

//------------------------------------------------------------------------------------------
// Value Extraction Functions
//------------------------------------------------------------------------------------------

void builtin_function() #BuiltInFunction :
{
  Token t;
  int functionType;
}
{
  (
    ( t = <MM_TO_UPPER_CASE> { functionType = t.kind; }
      | t = <MM_TO_LOWER_CASE> { functionType = t.kind; }
      | t = <MM_TRIM> { functionType = t.kind; }
      | t = <MM_PRINTF> { functionType = t.kind; }
      | t = <MM_DECIMAL_FORMAT> { functionType = t.kind; }
      | t = <MM_REVERSE> { functionType = t.kind; }
      | t = <MM_CAPTURING> { functionType = t.kind; }
      | t = <MM_REPLACE> { functionType = t.kind; }
      | t = <MM_REPLACE_ALL> { functionType = t.kind; }
      | t = <MM_REPLACE_FIRST> { functionType = t.kind; }
      | t = <MM_APPEND> { functionType = t.kind; }
      | t = <MM_PREPEND> { functionType = t.kind; }
    ) ( "(" argument_list() ")" )?
    | ( "[" ( argument_list() )? "]" ) { functionType = MM_CAPTURING; }
  )
  {
    jjtThis.functionType = functionType;
  }
}

void argument_list() #ArgumentList : {}
{
  argument() ( "," argument() )*
}

void argument() #Argument : {}
{
  ( reference_notation()
    | literal()
  )
}

//------------------------------------------------------------------------------------------
// Literal Values
//------------------------------------------------------------------------------------------

int integer_value() :
{
  Token t;
}
{
  t = <INTEGER_LITERAL>
  {
    return Integer.parseInt(t.image);
  }
}

float float_value() :
{
  Token t;
}
{
  t = <FLOAT_LITERAL>
  {
    return Float.valueOf(t.image);
  }
}

String string_value() :
{
  Token t;
  String str;
}
{
  t = <STRING_LITERAL> 
  {
    str = t.image;
    return str.substring(1, str.length() - 1);
  }
}

boolean boolean_value() :
{
  Token t;
  boolean value;
}
{
  ( <TRUE> { value = true; } | <FALSE> { value = false; } )
  {
    return value;
  }
}

//------------------------------------------------------------------------------------------
// Literal Datatypes
//------------------------------------------------------------------------------------------

int datatype() :
{
  Token t;
}
{
  ( t = <XSD_STRING>
    | t = <XSD_DECIMAL>
    | t = <XSD_BYTE>
    | t = <XSD_SHORT> 
    | t = <XSD_INTEGER>
    | t = <XSD_LONG>
    | t = <XSD_FLOAT>
    | t = <XSD_DOUBLE>
    | t = <XSD_BOOLEAN>
    | t = <XSD_TIME>
    | t = <XSD_DATETIME>
    | t = <XSD_DATE>
    | t = <XSD_DURATION>
    | t = <RDF_PLAINLITERAL>
  )
  {
    return t.kind;
  }
}

//------------------------------------------------------------------------------------------
// Enumeration Types
//------------------------------------------------------------------------------------------

int value_encoding() :
{
  Token t;
  int encodingType;
}
{
  ( t = <RDF_ID> { encodingType = t.kind; }
    | t = <RDFS_LABEL> { encodingType = t.kind; }
    | t = <OWL_LITERAL> { encodingType = t.kind; }
  )
  {
    return encodingType;
  }
}

int iri_encoding() :
{
  Token t;
  int encodingType;
}
{
  ( t = <MM_NO_ENCODE> { encodingType = t.kind; }
    | t = <MM_CAMELCASE_ENCODE> { encodingType = t.kind; }
    | t = <MM_SNAKECASE_ENCODE> { encodingType = t.kind; }
    | t = <MM_UUID_ENCODE> { encodingType = t.kind; }
    | t = <MM_HASH_ENCODE> { encodingType = t.kind; }
  )
  {
    return encodingType;
  }
}

int reference_type() #ReferenceType :
{
  Token t;
  int datatype;
}
{
  ( t = <OWL_CLASS> { referenceType = t.kind; }
   | t = <OWL_NAMED_INDIVIDUAL> { referenceType = t.kind; }
   | t = <OWL_OBJECT_PROPERTY> { referenceType = t.kind; }
   | t = <OWL_DATA_PROPERTY> { referenceType = t.kind; }
   | t = <OWL_ANNOTATION_PROPERTY> { referenceType = t.kind; }
   | t = <OWL_IRI> { referenceType = t.kind; }
   | t = <MM_ENTITY_IRI> { referenceType = t.kind; }
   | datatype = datatype()
     {
       referenceType = datatype;
       valueDatatype = datatype; // assign as well as property value datatype
     }
  )
  {
    return referenceType;
  }
}

int property_type() :
{
  Token t;
  int propertyType;
}
{
  ( t = <OWL_DATA_PROPERTY> { propertyType = t.kind; }
    | t = <OWL_OBJECT_PROPERTY> { propertyType = t.kind; }
    | t = <OWL_ANNOTATION_PROPERTY> { propertyType = t.kind; }
  )
  {
    return propertyType;
  }
}

int shift_direction() :
{
  Token t;
  int shiftDirection;
}
{
  ( t = <MM_SHIFT_UP> { shiftDirection = t.kind; }
    | t = <MM_SHIFT_DOWN> { shiftDirection = t.kind; }
    | t = <MM_SHIFT_LEFT> { shiftDirection = t.kind; }
    | t = <MM_SHIFT_RIGHT> { shiftDirection = t.kind; }
    | t = <MM_NO_SHIFT> { shiftDirection = t.kind; }
  )
  {
    return shiftDirection;
  }
}

int order_if_cell_empty() :
{
  Token t;
  int orderIfCellEmpty;
}
{
  ( t = <MM_CREATE_IF_CELL_EMPTY> { orderIfCellEmpty = t.kind; }
    | t = <MM_IGNORE_IF_CELL_EMPTY> { orderIfCellEmpty = t.kind; }
    | t = <MM_WARNING_IF_CELL_EMPTY> { orderIfCellEmpty = t.kind; }
    | t = <MM_ERROR_IF_CELL_EMPTY> { orderIfCellEmpty = t.kind; }
  )
  {
    return orderIfCellEmpty;
  }
}

int order_if_entity_absent() :
{
  Token t;
  int orderIfEntityAbsent;
}
{
  ( t = <MM_CREATE_IF_ENTITY_ABSENT> { orderIfEntityAbsent = t.kind; }
    | t = <MM_IGNORE_IF_ENTITY_ABSENT> { orderIfEntityAbsent = t.kind; }
    | t = <MM_WARNING_IF_ENTITY_ABSENT> { orderIfEntityAbsent = t.kind; }
    | t = <MM_ERROR_IF_ENTITY_ABSENT> { orderIfEntityAbsent = t.kind; }
  )
  {
    return orderIfEntityAbsent;
  }
}

int order_type() :
{
  Token t;
  int orderType;
}
{
  ( t = <CREATE> { orderType = t.kind; }
    | t = <IGNORE> { orderType = t.kind; }
    | t = <WARNING> { orderType = t.kind; }
    | t = <ERROR> { orderType = t.kind; }
  )
  {
    return orderType;
  }
}